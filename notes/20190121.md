(Happy MLK day!)

I think I've gotten `IRef` beaten into shape. It's costlier than it was, but
given that the cheap version couldn't handle fat pointers, so be it. It's still
fairly cheap.

---

Nope! And in fact it cannot work as designed, as far as I can tell.

The problem is rather subtle. I wanted to write this:

    static RASTER: IRef<dyn FnMut(RasterCtx)> = IRef::new();

Note the `dyn`.

My goal was to pass a stack-allocated closure, under very carefully controlled
circumstances, to an interrupt handler, where it would be executed by (fat)
reference. Such a closure should be able to borrow variables from its enclosing
scope -- that's kind of the point.

However, I kept getting a magic additional `'static` bound from nowhere, which
bans that useful class of closures.

It turns out to have nothing to do with the fact that I'm declaring a `static`
object. Oh, no, not at all.

No: the problem is that naming a trait object type like that, outside of the
context of a reference, *generates an automatic `'static` bound.*

This fact is *incredibly difficult to discover.* Near as I can tell it's
undocumented; I found out about it by reading a bug thread on github, where it's
mentioned offhand. Super frustrating.

So. We cannot name the type of the trait object, lest the compiler jump to
conclusions. What about specializing the `IRef` type? So you'd have

    static RASTER: IRef = IRef::new();

then we wind up trying to declare storage inside IRef like this:

    contents: UnsafeCell<Option<NonNull<
        dyn for<'a> FnMut(&'a mut RasterCtx)
        >>>,

aaaand guess what? `rustc` treats this as a trait bound, and `Unsafe::new` is no
longer `const`. (For all I know, it is the auto-generated `'static` that's
breaking things -- that sure looks like a trait bound.)

While I'm doing something pretty strange here, I'm still really frustrated at
the oblique and undocumented error messages I've been getting.

So.

I'll just brute force it.

How do we store a `FnMut` trait object reference? Why, of course:

    contents: UnsafeCell<(usize, usize)>,

Wheeeeeee

With that and some transmuting, we're good.

So, how fragile is this awful contraption? I think we're actually okay.

- We treat the pair of `usize` as opaque and don't assign any particular meaning
  to its contents.
- While we initialize it with zeros, it won't be observed until after being
  `LOADED` with non-zeros.
- Should a closure pointer change size, `transmute` will fail to compile.
- We are not relying on fat pointer reads or writes being atomic.


This approach is unfortunate, though, because of how specialized it is. I have
to hardcode even the closure argument types. This is because the `Fn` traits
aren't stable, so I can't parameterize it on a tuple of argument types.

Unless I pass a tuple.

So the problem there is it's not obvious how to express the HRTB on the
arguments. And I'm having a hard time finding examples on the googles.

Well, whatever -- I don't have to generalize it now.

---


